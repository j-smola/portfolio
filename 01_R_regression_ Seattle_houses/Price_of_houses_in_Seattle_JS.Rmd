---
title: "Price of houses in Seattle"
author: "Janina Smo≈Ça"
date: "27/05/2018"

output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    highlight: pygments
---

<!-- OSTYLOWANIE -->
<style>
#TOC {
overflow:auto;
}
body {
text-align: justify
}
h1 {
font-size: 22px
}
h2 {
font-size: 20px
}
h3 {
font-size: 18px
}
h1, .h1, h2, .h2, h3, .h3 {
margin-top: 20px;
}
p.caption {
font-style: bold;
margin-bottom: 30px;
margin-top: -10px;
text-align: middle;
}
pre code {
font-size: 11px;
}
</style>

```{r, warning=FALSE, include=FALSE}
library(dplyr)
library(ggplot2)
library(DataExplorer)
library(corrplot)
library(caTools)
library(e1071)
library(randomForest)
library(Metrics)
library(tseries)

col_mean <- "#8B0075"
col_med <- "#95BD00" 
col_max <- "#094481"
par(oma = c(0, 0, 0, 0))
```

<br>

# DATA

## Source 
```{r, warning=FALSE, include=FALSE}
df_house_0 <- read.csv('//house.csv')
# object to work
df_house <- df_house_0
```

According to the instruction from Client - only columns with no 1:15 should be used for model building purposes, that is:

| name | type | description |
|-------|------|------------------------|
| id | str | database identifier of the current row |
| date | str | pricing date |
| price | float | the price |
| bedrooms | float | number of bedrooms |
| bathrooms | float | number of bathrooms |
| sqft_living | float | living space area |
| sqft_lot | int | lot area |
| floors | float | number of floors |
| waterfront | int | indicator of whether the property is facing water {0,1} |
| view | int | quality of view from the property (0:4) |
| condition | int | property condition (1:5) |
| grade | int | property grade (1:13) |
| sqft_above | int | living area above ground level |
| sqft_basement | int | area of basement |
| yr_built | int | year the building was built |


Size of dataset
```{r}
dim(df_house)
```
<br>

## Quick look on dataset

```{r fig.align="center", warning=FALSE, fig.cap="Histograms"}
plot_histogram(df_house[2:15], ggtheme = theme_minimal(), ncol = 3L, 
               geom_histogram_args = list(fill = 'darkorange'),
               theme_config = list(axis.line = element_line(colour = "grey")))
```


```{r, fig.align="center", fig.cap="Corrplot"}
corrplot.mixed(cor(df_house[3:15]), tl.cex = 0.8, tl.col = 'grey36', tl.pos = 'lt', 
               diag = 'n', cl.cex = 0.8, number.cex = 0.7, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'linen', 'darkorange'))(20),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2)
)
```

<u>FIRST OBSERVATION ABOUT DATA SET</u>

- variables _waterfront_, _view_, _condition_ and _grade_ are the categorical type variable (Factor),

- variable _date_ has to be change to date type,

- to consideration: variable _yr_built_ has to be change to date type,

- to consideration: variable _id_ has to be in normal not scientific format,

- question: why variable _bathrooms_ - number of bathrooms - has not integer value?

- question: why variable _floors_ - number of floor - has not integer value? (mezzanine?)

- question: what describes variable _condition_? is that the expert opinion (subjective)
or same evaluation made on an objective scale?

- question: what has coded variable _grade_?

- quite good correlation (DV): _price_ ~ _sqft_living_, _price_ ~ _grade_, _price_ ~ _sqft_above_

- very strong correlation:  _sqft_above_ ~ _sqft_living_ (are they dependant?), 

- quite good correlation: _sqft_above_ ~ _bathrooms_, _sqft_living_ ~ _grade_, _sqft_above_ ~ _grade_, 
_bathrooms_ ~ _grade_, _bathrooms_ ~ _sqft_above_

<br>

<u>TYPES OF VARIABLES</u>

* variable - object identifier: _id_

* dependent variable - continuous variable: _price_

* independent variable - numerical variable (discrete): _date_, _bedrooms_, _bathrooms_, _floors_, _yr_built_

* independent variable - numerical variable (continuous): _sqft_living_, _sqft_lot_, _sqft_above_, _sqft_basement_ 

* independent variable - categorical variable (nominal): _waterfront_, _view_, _grade_

* independent variable - categorical variable (probably ordinal): _condition_

<br>

## NAs check
Checking if any NAs are in the data
```{r}
any(is.na(df_house))
```
<!-- ```{r, fig.align="center", fig.cap="Image of spare matrix = transaction & products"} -->
<!-- plot_missing(df_house) -->
<!-- ``` -->

<br>

# EDA

## Variable _price_
```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of house prices"}
boxplot(df_house$price/1000, horizontal = TRUE, col = 'darkorange', 
        main = '', xlab = 'price [k$]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r, fig.align="center", fig.height=3, fig.cap="Histogram of house prices"}
hist(df_house$price/1000, col = 'darkorange', breaks = 80, las = 1,
     main = '', xlab = 'price [k$]', cex.axis = 0.8, cex.lab = 0.8)
grid()
abline(v = c(mean(df_house$price)/1000, median(df_house$price)/1000), col = c(col_mean, col_med), lwd = 2)
```

## Variable _date_

Bulid new variable - the proper format of date for variable _date_
```{r}
df_house$date_pro <- as.Date(df_house$date, '%Y%m%dT000000')
```

```{r, warning=FALSE, include=FALSE}
# list of unique data of pricing (help for plot)
ls_unique_data_pro <- sort(unique(df_house$date_pro))
ls_unique_data_pro[1] # "2014-05-02"
ls_unique_data_pro[length(ls_unique_data_pro)] # "2014-05-27"
which(ls_unique_data_pro == '2014-12-31') ## 241
```
When were the most homes priced?
```{r}
max(table(df_house$date_pro))
which.max(table(df_house$date_pro))
```

```{r, fig.align="center", fig.height=3, fig.cap="Plot of number of houses priced in the time division (days)"}
barplot(table(df_house$date_pro), ylim = c(0, 160), col = 'darkorange', border = 'darkorange', las = 2,
        ylab = 'count', main = '', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.65)
abline(h = mean(table(df_house$date_pro)), col = col_mean)
abline(h = median(table(df_house$date_pro)), col = col_med)
abline(h = max(table(df_house$date_pro)), col = col_max)
text(x = 1, y = c(mean(table(df_house$date_pro)), median(table(df_house$date_pro)), max(table(df_house$date_pro))) + 5,
     col = c(col_mean, col_med, col_max), labels = c('mean', 'median', 'max'),  cex = 0.8)
```

**REMARKS** During summer months much more houses are valued than at the beginning of the year (winter).


Buliding new variable - 'date_Ym' built only on information about year and month of pricing date
```{r}
df_house$date_Ym <- strftime(as.Date(df_house$date, '%Y%m%dT000000'), '%Y-%m')
head(df_house$date_Ym)
```

```{r, fig.align="center", fig.height=4, fig.cap="Plot of number of houses priced in the time division (months)"}
barplot(table(df_house$date_Ym), las = 2, col = 'darkorange', ylim = c(0, 2500),
        main = '', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
abline(h = mean(table(df_house$date_Ym)), col = col_mean)
abline(h = median(table(df_house$date_Ym)), col = col_med)
abline(h = max(table(df_house$date_Ym)), col = col_max)
text(x = 1, y = c(mean(table(df_house$date_Ym)), median(table(df_house$date_Ym)), 
                  max(table(df_house$date_Ym))) + 50,
     col = c(col_mean, col_med, col_max), labels = c('mean', 'median', 'max'),  cex = 0.9)
```


## Variable _id_

Changing scientific format of id to more user friendly character format
```{r}
format(df_house$id, scientific = FALSE)[1:10]

df_house$id <- format(df_house$id, scientific = FALSE) %>% stringr::str_trim()
```

Checking if there are no duplicated items
```{r}
length(unique(df_house$id)) 
```

**ATTENTION** there are some duplicated ids 
```{r}
length(df_house$id) - length(unique(df_house$id))
```
Example
```{r}
filter(df_house, id == 1000102)
filter(df_house, id == 7200179)
filter(df_house, id == 109200390)
```

**REMARK** Only one diffrence in duplicated item is variable _date_ (also new built based on it - _date_pro_
and _date_Ym_) and  variable _price_ (?)

List of duplicated ids
```{r}
ls_dup_id <- df_house$id[duplicated(df_house$id)]
length(ls_dup_id) 
```

List of duplicate ids with _price_ and date of pricing _date_pro_ (for analysis what is different)
```{r}
filter(df_house, id %in% ls_dup_id) %>% select(id, price, date_pro) %>% head(10)
filter(df_house, id %in% ls_dup_id) %>% select(date_Ym) %>% table()
```

Checking number of duplicates (there can be some triplicate)
```{r, fig.align="center", fig.height=3, fig.cap="Plot of triplicate"}
filter(df_house, id %in% ls_dup_id) %>% select(id) %>% table() %>% plot(xaxt = 'n', col = c('darkgray', 'darkorange')[1+(. == max(.))], las = 1, frame = FALSE, cex.axis = 0.8)
```
Some items occure 3 times - checking:
```{r}
filter(df_house, id %in% ls_dup_id) %>% select(id) %>% table() %>% which.max()
filter(df_house[1:15], id == 795000620)
```

**REMARK** Each time the price is different!

Minor df: data frame with duplicated ids (for comparision how the price changes)
```{r}
df_dup_id <- filter(df_house, id %in% ls_dup_id, id != 795000620) %>% select(id, price, date_pro) 
```

Minor df: data frame with difference between price of houses with duplicate ids
```{r}
df_delta_dup_id <- data.frame(id = filter(df_dup_id, row_number() %% 2 == 0)[ , 1],
                              delta = filter(df_dup_id, row_number() %% 2 == 0)[ , 2] - filter(df_dup_id, row_number() %% 2 == 1)[ , 2])
```

```{r, fig.align="center", fig.height=3, out.width = "100%", fig.cap="Plot of price difference for duplicates"}
plot(sort(df_delta_dup_id$delta)/1000, type = 'h', las = 1,
     col = ifelse(sort(df_delta_dup_id$delta) > 0 , 'darkgray', 'darkorange'),
     ylab = 'delta [k$]', xlab = 'no of id', main = '',
     cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
points(x = which(sort(df_delta_dup_id$delta) == 0), y = rep(0, 3), 
       pch = 'x', col = col_max, cex = 0.5)
```

3 items were pricing twice and the price of the house wasn't changed => should they be treated as duplicates?
```{r}
filter(df_delta_dup_id, delta == 0) %>% nrow()  
filter(df_delta_dup_id, delta == 0)[ , 1] 
```

6 items were pricing twice and the price of the house has dropped over time
```{r}
filter(df_delta_dup_id, delta < 0) %>% nrow()  
filter(df_delta_dup_id, delta < 0)[ , 1] 
```

166 items were pricing twice and the price of the house has increased over time
```{r}
filter(df_delta_dup_id, delta > 0) %>% nrow() 
filter(df_house[ , c(1:15,22:23)], id %in% filter(df_delta_dup_id, delta < 0)[ , 1])
```

**DUPLICATED?** the same price - diffrent pricing date

```{r}
filter(df_house[ , c(1:15,22:23)], id %in% filter(df_delta_dup_id, delta == 0)[ , 1])
```

**REMARKS**
In dataset are 177 items that have duplicated id (exception id = 795000620 listed 3 times) - the diffrence is only in variable _date_ and _price_ (with 3 exception where the price is the same).
In the model, the variable _id_ will not be used, so it is important to decide how to deal with these duplicates.


**PROPOSAL:** cancel only second item with the same _id_ from the ids' list with the same price and diffrent pricing date.

Bulid new variable - indicators of whether to delete the given item
```{r, warning=FALSE, include=FALSE}
df_house$rm <- 0
```

List of duplicated items - houses for that the price is the same on diffrent pricing date
```{r}
(ls_rm_3id <- filter(df_house, id %in% filter(df_delta_dup_id, delta == 0)[ , 1]) %>% 
   filter(row_number() %% 2 == 0))
df_house[df_house$id %in%  ls_rm_3id$id, 'rm'] <- 1
```

<u>Checked</u>
```{r}
filter(df_house, id %in% filter(df_delta_dup_id, delta == 0)[ , 1])
```

<br>

## Variable _bedrooms_

<!-- ```{r} -->
<!-- table(df_house$bedrooms) -->
<!-- summary(df_house$bedrooms) -->
<!-- ``` -->

```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of bedrooms"}
boxplot(df_house$bedrooms, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'number of bedrooms', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

**ATTENTION**

According to the american standards for houses appraisal (given data set is a list of houses located in area of Seattle,
state of Washington) bedroom must be of adequate size (100 square feet or more), have a closet, a window and a door. 
It must be heated/cooled and finished in the same quality as the rest of the house. It must also 
be above grade and have reasonable access to a full bathroom. Basement bedrooms (50% below adjacent 
grade level) may <u>NOT</u> be counted in the total bedrooms count.


**OUTLIER OR MISTAKE ?**
```{r}
filter(df_house[ , c(1:15,22:24)], bedrooms == 33)
```

Analysis of similar items (only one parametres) 
```{r, fig.align="center", fig.height=5, fig.cap="Analysis of parameters for houses to outlier 33 (separately)"}
par(mfcol = c(2, 3))
filter(df_house, grade == 7) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Grade ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], 
          cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
filter(df_house, bathrooms == 1.75) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Bathrooms ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], 
          cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
filter(df_house, sqft_living == 1620) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Sqft_living ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], 
          cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
filter(df_house, floors == 1) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Floors ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], 
          cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
filter(df_house, price == 640000) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Price ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], 
          cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
filter(df_house, yr_built == 1947) %>% select(bedrooms) %>% table() %>% 
  barplot(., las = 1, main = 'Yr_built ~ bedrooms', col = c('gray', 'darkorange')[1+(. == max(.))], cex.axis = 0.8, cex.names = 0.8, cex.main = 0.9)
```

**REMARKS** similar items (the same value for diffrent parameters: grade = 7, bathrooms = 1.75, sqft_living = 1620,
floors = 1, price = 640000, yr_built = 1947) show that the most popular value for badrooms is 3.


Analysis of similar items (all parametres)
```{r, fig.align="center", fig.height=3, fig.cap="Analysis of parameters for houses to outlier 33 (all in one)"}
filter(df_house, grade == 7,
       bathrooms >= 1.75 - 0.75, bathrooms <= 1.75 + 0.75, # +/1 0.75 of 1.75
       sqft_living >= 0.9 * 1620, sqft_living <= 1.1 * 1620,  # +/- 10% of 1620
       price >= 0.85 * 640000, price <= 1.15 * 640000,   # +/- 15% of 640000
       yr_built >= 1947 - 5, yr_built <= 1947 + 5  # +/- 5yrs to 1947
) %>% select(bedrooms) %>% table() %>% barplot(., main = '', col = c('gray', 'darkorange')[1+(. == max(.))], 
                                               las = 1, cex.axis = 0.8, cex.names = 0.8)
```

<u>DECISION:</u> it is a mistake &Rightarrow; 33 has to be change into 3
```{r}
df_house[df_house$bedrooms == 33, 'bedrooms'] <- 3
```

Re-analysis
```{r}
table(df_house$bedrooms)
summary(df_house$bedrooms)
```
```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of bedrooms"}
boxplot(df_house$bedrooms, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'number of bedrooms', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r, fig.align="center", fig.height=3, fig.cap="Plot of number of bedrooms"}
barplot(table(df_house$bedrooms), las = 1, col = 'darkorange',
        main = '', cex.axis = 0.8, cex.names = 0.8)
abline(h = mean(table(df_house$bedrooms)), col = col_mean)
```

**ARE THESE DATA PROPER?** to consideration: removing these items 
```{r}
filter(df_house[ , c(1:15,22:24)], bedrooms == 0)
```

**REMARKS** Basement bedrooms (50% below adjacent grade level) may <u>NOT</u> be counted in the total bedrooms 
count, but none of these items have basement. It's also possible that some of them do not meet with the requirements.

<br>

## Variable _floors_

```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of floors"}
boxplot(df_house$floors, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'number of floors', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

**ATTENTION** According to the american standards for houses appraisal (given data set is a list of houses located in area of Seattle,
state of Washington) attics and mezzanine should be count as half floor. So the data - even if the number of floor isn't integer - 
should be considered as correct. Basement should <u>NOT</u> be counted in the total floor count.

```{r, fig.align="center", fig.height=3, fig.cap="Plot of floors\' number"}
barplot(table(df_house$floors), las = 1, col = 'darkorange', 
        main = '', cex.axis = 0.8, cex.names = 0.8, )
abline(h = mean(table(df_house$floors)), col = col_mean)
abline(h = median(table(df_house$floors)), col = col_med)
text(x = 0.5, y = c(mean(table(df_house$floors)), median(table(df_house$floors))) + 500,
     col = c(col_mean, col_med), labels = c('mean', 'median'))
```

<br>

## Variable _waterfront_

```{r, fig.align="center", fig.height=3, fig.cap="Plot of waterfront"}
barplot(table(df_house$waterfront), las = 1, col = 'darkorange',
        names.arg = c('no facing water', 'facing water'),
        main = '', xlab = 'indicator of whether the property is facing water',
        cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

**REMARKS** Almost no house (only 0,7% of all) has a view of the water, what is quite interesting in the Seattle (port city).

<br>

## Variable _view_

```{r, fig.align="center", fig.height=3, fig.cap="Plot of view"}
barplot(table(df_house$view), las = 1, col = 'darkorange',
        main = '', xlab = 'quality of view from the property', 
        cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

<br>

## Variable _condition_

```{r, fig.align="center", fig.height=3, fig.cap="Plot of condition"}
barplot(table(df_house$condition), las = 1, col = 'darkorange',
        main = '', xlab = 'property condition', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

<br>

## Variable _grade_

```{r, fig.align="center", fig.height=3, fig.cap="Plot of grade"}
barplot(table(df_house$grade), las = 1, col = 'darkorange',
        main = '', xlab = 'property grade', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

Analysis: is the _grade_ dependant of _floors_?
```{r, fig.align="center", fig.height=2, fig.cap="Corrplot"}
corrplot.mixed(cor(df_house[ , c('price', 'floors', 'grade')]),
               tl.cex = 0.8, tl.col = 'grey36', main = '',
               diag = 'n', cl.cex = 0.8, number.cex = 0.8, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'linen', 'darkorange'))(10),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```


**REMARKS** correlation _grade_ ~ _floor_ is not really strong (0.46), but correlation _price_ ~ _grade_ is strong (0.67).

<br>

## Variable _yr_built_

```{r, fig.align="center", fig.height=3, fig.cap="Plot of yr_built"}
barplot(table(df_house$yr_built), las = 2, col = 'darkorange',
        main = '', xlab = 'year the building was built', cex.names = 0.65, cex.axis = 0.8, cex.lab = 0.8)
```

Analysis: is the _price_ dependant of _yr_built_ and _condition_?
```{r, fig.align="center", fig.height=2, fig.cap="Corrplot"}
corrplot.mixed(cor(df_house[ , c('price', 'yr_built', 'condition')]),
               tl.cex = 0.8, tl.col = 'grey36', #tl.pos = 'lt',
               diag = 'n', cl.cex = 0.8, number.cex = 0.8, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'darkorange'))(10),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```

**REMARKS** correlation _yr_built_ ~ _floor_ is not really strong (<0.05)

<u>Curiose:</u> how often happened the renovation?
```{r}
df_house[df_house$yr_renovated - df_house$yr_built > 0, ] %>% select(yr_built) %>% table() 
```
Not really often: only 914/21613 (4.2%) of houses was renovated
```{r}
filter(df_house, yr_renovated != 0) %>% nrow()
```

Bulid new variable: _house_age_ - to solve a problem with difference of house age that is bind with different pricing date
the price will be a function of one variable _house_age_ and not of two variables _date_ (pricing) and _yr_built_

**ATTENTION** That has also its consequences: after canceling _date_ (pricing) and _yr_built_ there will be not longer possible to analysis the price change according the month of pricing or differnce during the year.

```{r, warning=FALSE, include=FALSE}
strftime(as.Date(as.character(df_house$yr_built), '%Y'), '%Y') %>% unique()
df_house$house_age <- as.numeric(strftime(as.Date(df_house$date, '%Y%m%dT000000'), '%Y')) - df_house$yr_built
```

```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of house age"}
boxplot(df_house$house_age, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'house age [yrs]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, out.width = "100%", fig.cap="Plot of house age"}
barplot(table(df_house$house_age), las = 1, col = 'darkorange',
        main = '', xlab = 'house age [yrs]', cex.lab = 0.8, cex.axis = 0.8, cex.names = 0.8)
```

How many houses was priced in the year of its built?
```{r}
filter(df_house, house_age == 0) %>% nrow() ## 430

filter(df_house, house_age < 0) 
```
There are 12 items that have for _house age_ with value equal -1. It's possible that investor asked about pricing 
based on design - not based on really existing building. Not to put 'strange' data into model and because it's
only 12 items (0.06% of all) the value -1 will be change into 0 (the houses that were priced in the same 
year that were also built).

<u>Checked</u>
```{r}
df_house[df_house$house_age == -1, 'house_age'] <- 0
filter(df_house, house_age == -1) %>% select(house_age) 
```

Re-analysis
```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of house age[yrs]"}
boxplot(df_house$house_age, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = '', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, out.width = "100%", fig.cap="Plot of house age"}
barplot(table(df_house$house_age), las = 1, col = 'darkorange',
        main = '', xlab = 'house age', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

New minor variable _date_Y_ to check how the price is correlated with the pricing date?
```{r}
df_house$date_Y <- as.numeric(strftime(as.Date(df_house$date, '%Y%m%dT000000'), '%Y'))
```
```{r, fig.align="center", fig.height=3, fig.cap="Corrplot"}
corrplot.mixed(cor(df_house[ , c('price', 'yr_built', 'house_age', 'date_Y')]),
               tl.cex = 0.8, tl.col = 'grey36', #tl.pos = 'lt',
               diag = 'n', cl.cex = 0.8, number.cex = 0.8, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'darkorange'))(10),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```

**REMARKS** The price is not correlated with the pricing date so it was a good idea to build new variable _house_age_,
it's possible to cancle _yr_built_ and _date_ (with all group of variable based on it) and leave only _house_age_ .

<br>

## Variable _sqft_living_
```{r}
summary(df_house$sqft_living) ## 100sf = 9.29m2
summary(df_house$sqft_living)/(100/9.29) # m2
```

```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of living space area"}
boxplot(df_house$sqft_living, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'living space area [sqft]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, fig.cap="Histogram of living space area"}
hist(df_house$sqft_living, las = 1, col = 'darkorange', breaks = 70,
     main = '', xlab = 'living space area [sqft]', cex.axis = 0.8, cex.lab = 0.8)
```

* max (> 750 m2 ~ 8070sf)
```{r}
filter(df_house, sqft_living == 13540)
filter(df_house, sqft_living > 8070) %>% select(bedrooms, bathrooms) %>% table()
```

* min (< 50 m2 ~ 540sf)
```{r}
filter(df_house, sqft_living < 540) %>% select(bedrooms, bathrooms) %>% table()
```

<br>

## Variable _sqft_lot_

```{r}
summary(df_house$sqft_lot)
```
```{r}
summary(df_house$sqft_lot)/(100/9.29) # m2
```
```{r}
summary(df_house$sqft_lot)/1076.39 # ar
```


```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of lot area"}
boxplot(df_house$sqft_lot, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'lot area [sqft]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, fig.cap="Histogram of lot area"}
hist(df_house$sqft_lot, col = 'darkorange', breaks = 100,
     main = '', xlab = 'lot area [sqft]', cex.axis = 0.8, cex.lab = 0.8)
```

```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of living space area >10^5sqft"}
filter(df_house, sqft_lot > 100000) %>% select(sqft_lot) %>% 
  boxplot(horizontal = TRUE, col = 'darkorange',
          main = '', xlab = 'living space area [sqft]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

**REMARKS** There are big difference between the smallest and the biggest lot


<br>

## Variable _sqft_above_

```{r}
summary(df_house$sqft_above)
```
```{r}
summary(df_house$sqft_above)/(100/9.29) # m2
```
```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of living area above ground level"}
boxplot(df_house$sqft_above, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'living area above ground level [sqft]', 
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, fig.cap="Histogram of space area above"}
hist(df_house$sqft_above, col = 'darkorange', las = 1, breaks = 80,
     main = '', xlab = 'space area above [sqft]', cex.axis = 0.8, cex.lab = 0.8)
```

<!-- ```{r} -->
<!-- table(df_house$sqft_above, df_house$floors) -->
<!-- ``` -->

Average floor area
```{r}
summary(round(df_house$sqft_above/df_house$floors, 2))
```

```{r, fig.align="center", fig.height=3, fig.cap="Histogram of  average floor area"}
hist(round(df_house$sqft_above/df_house$floors, 2), las = 1, col = 'darkorange', breaks = 50,
     main = '', xlab = ' average floor area [sqft]', cex.axis = 0.8, cex.lab = 0.8)
```

<br>

## Variable _sqft_basement_

```{r}
summary(df_house$sqft_basement)
```
```{r}
summary(df_house$sqft_basement)/(100/9.29) # m2
```
The most popular basement area
```{r}
sort(table(df_house$sqft_basement), decreasing = TRUE)[1:10]
```
```{r, fig.align="center", fig.height=3, fig.cap="Boxplot of area of basement"}
boxplot(df_house$sqft_basement, horizontal = TRUE, col = 'darkorange',
        main = '', xlab = 'area of basement [sqft]', cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```

```{r, fig.align="center", fig.height=3, fig.cap="Histogram of basement area"}
hist(df_house$sqft_basement, las = 1, col = 'darkorange', breaks = 50,
     main = '', xlab = 'basement area [sqft]', cex.axis = 0.8, cex.lab = 0.8)
```

```{r}
filter(df_house, sqft_basement == 0) %>% nrow()
```

**REMARK** 60% (13126/21613) of houses do not have basement
<br>
Which houses according to the number of floor do and do not have basement?
```{r}
filter(df_house, sqft_basement == 0) %>% select(floors) %>% table()
filter(df_house, sqft_basement != 0) %>% select(floors) %>% table()
```

**REMARK** more-less: houses with floor number between 1.5 to 3.5 floors more often do not have than have the basement
<br>
Bulid new variable: _is_basement_ indicator if the house has basement - to consideration (as bottom)
```{r, warning=FALSE, include=FALSE}
filter(df_house, sqft_basement == 0) %>% nrow() ## 13126
filter(df_house, sqft_basement != 0) %>% nrow() ## 8487

df_house[df_house$sqft_basement == 0, 'is_basement'] <- 0
df_house[df_house$sqft_basement != 0, 'is_basement'] <- 1
```
```{r}
table(df_house$is_basement)
```

```{r, fig.align="center", fig.height=3, fig.cap="Plot of basement indicator"}
barplot(table(df_house$is_basement), las = 1, col = 'darkorange',
        names.arg = c('without basement', 'with basement'),
        main = '', xlab = 'does house have basement?', cex.axis = 0.8, cex.lab = 0.8, cex.names = 0.8)
```

**ATTENTION** One variable can be removed.

```{r}
table(df_house$sqft_basement + df_house$sqft_above == df_house$sqft_living)
table(round((df_house$sqft_above/df_house$sqft_living), 2))
```

```{r, fig.align="center", fig.height=3, fig.cap="Corrplot"}
corrplot.mixed(cor(df_house[ , c('price', 'sqft_lot', 'sqft_basement', 'sqft_above', 
                                 'sqft_living', 'is_basement', 'floors')]),
               tl.cex = 0.8, tl.col = 'grey36', tl.pos = 'lt',
               diag = 'n', cl.cex = 0.8, number.cex = 0.8, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'darkorange'))(10),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```

**REMARKS** Because variables _sqft_above_ and _sqft_living_ are in strong correlation (0.88) - the best solution
will be to cancle one of them. 

**TO CONSIDERATION:** pairs of variables: _sqft_basement_ & _sqft_above_ or _sqft_living_ & _is_basement_


<br><br>

# FINAL DATASET 

## Proper dataset
```{r}
colnames(df_house[c(3:14, 25, 27)])
```

<u>Removed rows</u>: 

* 3 because of duplicated _id_; 

* 3 because of no bathrooms; 

* 7 because of no bedrooms, no bathrooms and no basement

```{r}
df_house[df_house$rm == 1, ]  
dim(df_house[df_house$rm == 1, ])
```

```{r}
df_house_an <- df_house[df_house$rm == 0, c(3:14, 25, 27)]
dim(df_house_an)
```

Correlation
```{r, fig.align="center", fig.cap="Corrplot"}
corrplot.mixed(cor(df_house_an), tl.cex = 0.8, tl.col = 'grey36', tl.pos = 'lt', 
               diag = 'n', cl.cex = 0.8, number.cex = 0.7, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'darkorange'))(20),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```

## Selection of variable with reggresion
Checking pairs: _sqft_basement_ + _sqft_above_ or _is_basement_ + _sqft_living_
```{r}
model_lm_1 <- lm(price ~ . - sqft_living - is_basement , data = df_house_an)
summary(model_lm_1)
```

```{r}
model_lm_2 <- lm(price ~ . - sqft_above  - sqft_basement , data = df_house_an)
summary(model_lm_2)
```
Veryfication of AIC and BIC
```{r}
stats::AIC(model_lm_1, model_lm_2)
```
```{r}
stats::BIC(model_lm_1, model_lm_2)
```

**REMARKS** better is model_lm_2 with _is_basement_ + _sqft_living_ however it's a minimal lead.

**ATTENTION** In the model_lm_2 the variable 'is_basement' seems be not important

<br>

### Models for procedur of stepwise selection by AIC 
```{r}
model_start <- lm(price ~ 1 , data = df_house_an) 
summary(model_start)
```

```{r}
model_full <- lm(price ~ . , data = df_house_an)
summary(model_full)
```

**REMARKS** NA for _sqft_basement_ shows because of dependence with _sqft_above_ and _sqft_living_ 
However variable _sqft_living_ has the strongest influence for _price_; it seems also that
_sqft_above_ and _is_basement_ probabaly can be cancled.

<br>

### Backward stepwise model selection by AIC

```{r}
reg_final_b <- MASS::stepAIC(model_full, direction = 'backward', steps = 20) 
reg_final_b$anova
```

<br>

### Forward stepwise model selection by AIC
```{r}
reg_final_f <- MASS::stepAIC(model_start, 
                             scope = list(lower = model_start, upper = model_full), 
                             direction = 'forward') 
reg_final_f$anova
```

<br>

### Both direction stepwise model selection by AIC
```{r}
reg_final_b <- MASS::stepAIC(model_start, 
                             scope = list(lower = model_start, upper = model_full),
                             direction = 'both')
reg_final_b$anova
```

<br>

## Final dataset 

```{r}
df_house_fin <- df_house_an[ , c(1:10, 13:14)]
dim(df_house_fin)
colnames(df_house_fin)
```
```{r, fig.align="center", fig.cap="Corrplot"}
corrplot.mixed(cor(df_house_fin), tl.cex = 0.8, tl.col = 'grey36', tl.pos = 'lt', 
               diag = 'n', cl.cex = 0.8, number.cex = 0.7, number.font = 2,
               upper.col = colorRampPalette(c('darkgray', 'linen', 'darkorange'))(20),
               lower.col = colorRampPalette(c('darkgray', 'darkorange'))(2))
```
Last check of final detaset
```{r}
anova(lm(price ~ . , data = df_house_fin))
```

**ATTENTION** According to the analysis-of-variance for the final data probably it should be also considered
model without varaibles _floors_ and _is_basement_

<br>

## Train-test split
```{r}
split_house <- sample.split(df_house_fin, SplitRatio = 0.8)
```
Train set
```{r}
train_house <- subset(df_house_fin, split_house == TRUE)
dim(train_house)
```
Test set
```{r}
test_house <- subset(df_house_fin, split_house == FALSE)
dim(test_house) 
```

<br><br>

# MODEL: REGRESSION

## Model
```{r}
model_lm <- lm(formula = price ~ . , data = train_house)
```
```{r}
summary(model_lm)
summary(model_lm)$adj.r.squared 
```

<br>

## Prediction
* test set
```{r}
y_pred_lm <- predict(model_lm, newdata = test_house)
res_lm <- test_house$price - y_pred_lm

summary(y_pred_lm)
length(y_pred_lm[y_pred_lm <= 0]) 
```

* train set
```{r}
y_pred_lm_0 <- predict(model_lm, newdata = train_house)
res_lm_0 <- train_house$price - y_pred_lm_0

summary(y_pred_lm_0)
length(y_pred_lm_0[y_pred_lm_0 <= 0])
```

**ATTENTION** model is giving value of 'price' less then 0
```{r}
summary(test_house$price)
```

<br>

## Model's test
Sufficiency of the functional part of the model: scatter plots of residuals versus predictors
```{r fig.align="center", out.width = "100%", fig.cap="Multiple Linear Regression: Residuals vs. predictors and real"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1)) 
plot(res_lm ~ y_pred_lm,
     pch = 4, main = '', xlab = 'predictors', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

plot(res_lm_0 ~ y_pred_lm_0,
     pch = 4, main = '', xlab = 'real', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

```
<u>Normality of errors</u>

* test set
```{r}
summary(res_lm)
```
```{r fig.align="center", fig.height=3, fig.cap="Multiple Linear Regression - residuals"}
boxplot(res_lm, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="Multiple Linear Regression: Histogram of residual (test)"}
hist(res_lm, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_lm) 
``` 
<u> Outcome</u> Residuals don't have a normal distribution

```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - Multiple Linear Regression (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1)) 
qqnorm(res_lm, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles\n') 
grid()
qqline(res_lm_0, col = col_main, lwd = 2)

qqplot(y_pred_lm, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```

* train set
```{r}
summary(res_lm_0)
```
```{r fig.align="center", fig.height=3, fig.cap="Multiple Linear Regression - residuals"}
boxplot(res_lm_0, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="Multiple Linear Regression: Histogram of residual (train)"}
hist(res_lm_0, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_lm_0) 
``` 
<u>Outcome</u> Residuals don't have a normal distribution


```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - Multiple Linear Regression (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1)) 
qqnorm(res_lm_0, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles\n') 
grid()
qqline(res_lm_0, col = col_main, lwd = 2)

qqplot(y_pred_lm_0, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```


# MODEL: SUPPORT VECTOR REGGRESION

## Model
```{r}
model_svr <- svm(formula = price ~ . , data = train_house,
                 type = 'eps-regression', kernel = 'radial')
summary(model_svr)
```

<br>

## Prediction
* test set
```{r}
y_pred_svr <- predict(model_svr, newdata = test_house)
res_svr <- test_house$price - y_pred_svr

summary(y_pred_lm)
```

* train set
```{r}
y_pred_svr_0 <- predict(model_svr, newdata = train_house)
res_svr_0 <- train_house$price - y_pred_svr_0
```

<br>

## Model's test

Sufficiency of the functional part of the model: scatter plots of residuals versus predictors
```{r fig.align="center", out.width = "100%", fig.cap="SVR: Residuals vs. predictors and real"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1))
plot(res_svr ~ y_pred_svr,
     pch = 4, main = '', xlab = 'predictors', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

plot(res_svr_0 ~ y_pred_svr_0,
     pch = 4, main = '', xlab = 'real', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

```
<u>Normality of errors</u>

* test set
```{r}
summary(res_svr)
```
```{r fig.align="center", fig.height=3, fig.cap="SVR - residuals"}
boxplot(res_svr, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="SVR: Histogram of residual (test)"}
hist(res_svr, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_svr) 
``` 
<u> Outcome</u> Residuals don't have a normal distribution

```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - SVR (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1))
qqnorm(res_svr, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles\n') 
grid()
qqline(res_svr_0, col = col_main, lwd = 2)

qqplot(y_pred_svr, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```

* train set
```{r}
summary(res_svr_0)
```
```{r fig.align="center", fig.height=3, fig.cap="SVR - residuals"}
boxplot(res_svr_0, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="SVR: Histogram of residual (train)"}
hist(res_svr_0, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_svr_0) 
``` 
<u>Outcome</u> Residuals don't have a normal distribution


```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - SVR (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1))
qqnorm(res_svr_0, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles\n') 
grid()
qqline(res_svr_0, col = col_main, lwd = 2)

qqplot(y_pred_svr_0, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```

<br>

# MODEL: RANDOM FOREST

## Model
```{r}
model_rf <- randomForest(x = train_house[-1], y = train_house$price, ntree = 100)
print(model_rf)

model_rf$mse[which.max(model_rf$rsq)] 
```

<br>

## Prediction
* test set
```{r}
y_pred_rf <- predict(model_rf, newdata = test_house)
res_rf <- test_house$price - y_pred_rf

summary(y_pred_rf)
```
* train set
```{r}
y_pred_rf_0 <- predict(model_rf, newdata = train_house)
res_rf_0 <- train_house$price - y_pred_rf_0

summary(y_pred_rf_0)
```

<br>

## Model's test

Sufficiency of the functional part of the model: scatter plots of residuals versus predictors
```{r fig.align="center", out.width = "100%", fig.cap="Random Forest: Residuals vs. predictors and real"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1))
plot(res_rf ~ y_pred_rf,
     pch = 4, main = '', xlab = 'predictors', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

plot(res_rf_0 ~ y_pred_rf_0,
     pch = 4, main = '', xlab = 'real', ylab = 'residuals\n',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
abline(h = 0, col = col_main, lwd = 2)

```
<u>Normality of errors</u>

* test set
```{r}
summary(res_rf)
```
```{r fig.align="center", fig.height=3, fig.cap="Random Forest - residuals"}
boxplot(res_rf, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="Random Forest: Histogram of residual (test)"}
hist(res_rf, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_rf) 
``` 
<u> Outcome</u> Residuals don't have a normal distribution

```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - Random Forest (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 5.1, 2.1, 2.1))
qqnorm(res_rf, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles') 
grid()
qqline(res_rf_0, col = col_main, lwd = 2)

qqplot(y_pred_rf, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```

* train set
```{r}
summary(res_rf_0)
```
```{r fig.align="center", fig.height=3, fig.cap="Random Forest - residuals"}
boxplot(res_rf_0, horizontal = TRUE, col = 'darkorange', main = '',
        cex.axis = 0.8, cex.lab = 0.8, frame = FALSE)
```
```{r fig.align="center", fig.height=3, fig.cap="Random Forest: Histogram of residual (train)"}
hist(res_rf_0, breaks = 100, col = 'darkorange', main = '',
     cex.axis = 0.8, cex.lab = 0.8, las = 1)
```
```{r}
tseries::jarque.bera.test(res_rf_0) 
``` 
<u>Outcome</u> Residuals don't have a normal distribution


```{r fig.align="center", fig.height=4, out.width = "100%", fig.cap="QQplot - Random Forest (train & test set)"}
par(mfcol = c(1, 2), mar = c(5.1, 6.1, 2.1, 2.1))
qqnorm(res_rf_0, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for train set', ylab = 'sample quantiles\n\n') 
grid()
qqline(res_rf_0, col = col_main, lwd = 2)

qqplot(y_pred_rf_0, test_house$price, cex.axis = 0.8, cex.sub = 0.8, cex.lab = 0.8, las = 1, 
       main = '', xlab = 'theoretical quantiles for test set', ylab = '')
grid()
abline(a = 0, b = 1, col = col_main, lwd = 2)
```

<br>

# COMPARISION OF MODELS

## Stat 

Number of items in test set 5400
```{r}
(n_data <- nrow(test_house))
```
Number of independent variable
```{r}
(p_data <- ncol(test_house) - 1)
```


```{r, warning=FALSE, include=FALSE}
# Function to calculate quality metrics for models
tab_stat <- function(y_pred, y_real, n_data, p_data){
  tab_stat_x <- NULL
  # Mean Squared Error
  tab_stat_x$mse <- mse(y_pred, y_real)
  # Root Mean Squared Error
  tab_stat_x$rmse <- rmse(y_pred, y_real)
  # Relative Squared Error
  tab_stat_x$rse <- sqrt(sse(y_real, y_pred)/(n_data - 2))
  # R-squared (R2) -  coefficient of determination
  R2_x <-  1 - rse(y_real, y_pred) #sse(y_real, y_pred) / sse(y_real, mean(y_real))
  tab_stat_x$R2 <- R2_x
  # adjusted R-squared 
  adjR2_x <- 1 - (1 - R2_x) * (n_data- 1)/(n_data - p_data - 1)
  tab_stat_x$adjR2 <- adjR2_x
  # return
  as.data.frame(tab_stat_x)
}
```
Metrics table for each model (test set)
```{r}
tab_lm <- tab_stat(y_pred_lm, test_house$price, n_data, p_data)
tab_svr <- tab_stat(y_pred_svr, test_house$price, n_data, p_data)
tab_rf <- tab_stat(y_pred_rf, test_house$price, n_data, p_data)
```

```{r, warning=FALSE, include=FALSE}
(tab_all <- rbind(tab_lm, tab_svr, tab_rf))
rownames(tab_all) <- c('tab_lm', 'tab_svr', 'tab_rf')

colnames(tab_all)
```

```{r}
tab_all
```

Checking the diffrence between R2 and adj R2
```{r}
(tab_all$R2 - tab_all$adjR2) / tab_all$R2 
```
**OUTCOME** Diffrence between R2 and adjR2 negligibly small = > we can use only R2

<br>

**SUMMARY OF METRICS TABLE**
```{r}
summary(tab_all)
```

<br>

## Metrics plot 
```{r fig.align="center", warning=FALSE, fig.height=6, fig.cap="Plot of quality metrics for all models"}
plot(tab_all[ , 2]/10^5, type = 'b', col = 'darkblue', lwd = 2,
     las = 2, xaxt = 'n', ylim = c(-0.5, 4),
     main = '', ylab = 'metrics value', xlab = 'model',
     cex.axis = 0.8, cex.lab = 0.8)
points(1:3, tab_all[ , 4], type = 'b', col = 'darkorange', lwd = 2, pch = 2)
points(1:3, tab_all[ , 3]/min(summary(test_house$price)), type = 'b', col = 'chartreuse', 
       lwd = 2, pch = 0, lty = 2)
points(1:3, tab_all[ , 3]/max(summary(test_house$price)), type = 'b', col = 'chartreuse', 
       lwd = 2, pch = 0, lty = 2)
axis(1, at = seq(1, 3, 1), labels = c('Multiple Linear Regression', 'SVR', 'Random Forest'), cex = 0.8)
legend('topleft', legend = c('RSE[10^-6]', 'R2', 'RMSE [10^-5]'),
       col = c('chartreuse', 'darkorange', 'darkblue'),
       pch = c(0, 2, 1), lwd = 2, lty = c(2, 1, 1),
       box.lty = 0, cex = 0.8, horiz = TRUE)
grid()
abline(h = 0, col = 'black')
```

<br>

<u>REMARKS TO VALUE THE MODEL</u>

- Lower values of RMSE indicate better fit.

- The smaller diffrence between RSE/min and RSE/max the better model is.

- The greater R2 is the better the model fits given data.

**CONCLUSION** Random forest is the best.

<br>

## Plots prediction~real 

```{r fig.align="center", warning=FALSE, fig.height=8, out.width = "100%", fig.cap="Plot of quality metrics for all models"}
par(mfcol = c(3, 1))
par(mar = c(5.1, 6.1, 2.1, 2.1))
plot(y_pred_lm ~ test_house$price, col = 'chartreuse', 
     ylim = c(0, 5350000), xlim = c(0, 5350000), cex = 0.8, cex.axis = 1.2, cex.lab = 1.2,
     main = 'Multiple Linear Regression', xlab = 'predictors', ylab = 'real\n', las = 1)
abline(a = 0, b = 1, col = 'darkgrey')
plot(y_pred_svr ~ test_house$price, col = 'darkorange', 
     ylim = c(0, 5350000), xlim = c(0, 5350000), cex = 0.8, cex.axis = 1.2, cex.lab = 1.2,
     main = 'SVR', xlab = 'predictors', ylab = 'real\n', las = 1)
abline(a = 0, b = 1, col = 'darkgrey')
plot(y_pred_rf ~ test_house$price, col = 'blue3', 
     ylim = c(0, 5350000), xlim = c(0, 5350000), cex = 0.8,cex.axis = 1.2, cex.lab = 1.2,
     main = 'Random Forest', xlab = 'predictors', ylab = 'real\n', las = 1)
abline(a = 0, b = 1, col = 'darkgrey')
```

**Random forest have good precison of prediction - the relation predicted value to the real lies on diagonal
that means that the error of prediction is small.**





